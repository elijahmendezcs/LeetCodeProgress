import java.util.List;

public class OneDynamicProgramming {


    // You are given an integer n representing the number of steps to reach the top of a staircase.
    // You can climb with either 1 or 2 steps at a time.

    // Return the number of distinct ways to climb to the top of the staircase.

    public int climbStairs(int n) {

        return n;
    }


    // You are given an integer array nums where nums[i] represents the amount of money the ith house has.
    // The houses are arranged in a straight line, i.e. the ith house is the neighbor of the (i-1)th and (i+1)th house.

    // You are planning to rob money from the houses,
    // but you cannot rob two adjacent houses because the security system will automatically alert the police
    // if two adjacent houses were both broken into.

    // Return the maximum amount of money you can rob without alerting the police.

    public int rob(int[] nums) {

        return 0;
    }


    // You are given an integer array nums where nums[i] represents the amount of money the ith house has.
    // The houses are arranged in a circle, i.e. the first house and the last house are neighbors.

    // You are planning to rob money from the houses, but you cannot rob two adjacent houses because
    // the security system will automatically alert the police if two adjacent houses were both broken into.

    // Return the maximum amount of money you can rob without alerting the police.

    public int rob2(int[] nums) {

        return 0;
    }

    // Given a string s, return the longest substring of s that is a palindrome.

    // A palindrome is a string that reads the same forward and backward.

    // If there are multiple palindromic substrings that have the same length, return any one of them.

    public String longestPalindrome(String s) {

        return s;
    }


    // Given a string s, return the number of substrings within s that are palindromes.

    // A palindrome is a string that reads the same forward and backward.

    public int countSubstrings(String s) {


        return 0;
    }


    // A string consisting of uppercase english characters can be encoded to a number using the following mapping:

    //'A' -> "1"
    //'B' -> "2"
    //...

    //'Z' -> "26"

    // To decode a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above.
    // There may be multiple ways to decode a message. For example, "1012" can be mapped into:

    // "JAB" with the grouping (10 1 2)
    // "JL" with the grouping (10 12)
    // The grouping (1 01 2) is invalid because 01 cannot be mapped into a letter since it contains a leading zero.

    // Given a string s containing only digits, return the number of ways to decode it.
    // You can assume that the answer fits in a 32-bit integer.

    public int numDecodings(String s) {

        return 0;
    }


    // You are given an integer array coins representing coins of different denominations
    // (e.g. 1 dollar, 5 dollars, etc.) and an integer amount representing a target amount of money.

    // Return the fewest number of coins that you need to make up the exact target amount.
    // If it is impossible to make up the amount, return -1.

    // You may assume that you have an unlimited number of each coin.

    public int coinChange(int[] coins, int amount) {

        return amount;
    }

    // Given an integer array nums, find a subarray that has the largest product within the array and return it.

    // A subarray is a contiguous non-empty sequence of elements within an array.

    // You can assume the output will fit into a 32-bit integer.

    public int maxProduct(int[] nums) {

        return 0;
    }

    // Given a string s and a dictionary of strings wordDict,
    // return true if s can be segmented into a space-separated sequence of dictionary words.

    // You are allowed to reuse words in the dictionary an unlimited number of times.
    // You may assume all dictionary words are unique.


    public boolean wordBreak(String s, List<String> wordDict) {

        return false;
    }


    // Given an integer array nums, return the length of the longest strictly increasing subsequence.

    // A subsequence is a sequence that can be derived from the given sequence by
    // deleting some or no elements without changing the relative order of the remaining characters.

    // For example, "cat" is a subsequence of "crabt".

    public int lengthOfLIS(int[] nums) {

        return 0;
    }


}
