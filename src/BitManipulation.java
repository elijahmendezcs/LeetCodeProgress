public class BitManipulation {


    // You are given an unsigned integer n. Return the number of 1 bits in its binary representation.

    // You may assume n is a non-negative integer which fits within 32-bits.

    public int hammingWeight(int n) {

        return n;
    }


    // Given an integer n,
    // count the number of 1's in the binary representation of every number in the range [0, n].

    // Return an array output where output[i] is the number of 1's in the binary representation of i.


    public int[] countBits(int n) {

        return new int[0];
    }

    // Given a 32-bit unsigned integer n,
    // reverse the bits of the binary representation of n and return the result.

    public int reverseBits(int n) {

        return n;
    }

    // Given an array nums containing n integers in the range [0, n] without any duplicates,
    // return the single number in the range that is missing from nums.
    //
    // Follow-up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?

    public int missingNumber(int[] nums) {

        return 0;
    }

    // Given two integers a and b,
    // return the sum of the two integers without using the + and - operators.


    public int getSum(int a, int b) {

        return a;
    }









}
